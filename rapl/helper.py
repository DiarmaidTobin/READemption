import concurrent.futures
import sys
from rapl.paths import Paths
from libs.sam import SamParser
from rapl.parameters import Parameters

class Helper(object):
    """Offers misc help for other classes"""

    def __init__(self):
        self.paths = Paths()
        self.parameters = Parameters()

    def get_header_of_genome_file(self, genome_file):
        """Return the shor header of a given fasta file."""
        genome_file_path = self.paths.genome_file(genome_file)
        return(open(genome_file_path).readline().split()[0][1:])

    def check_thread_completeness(self, threads):
        """Check the completness of each thread in a list

        Arguments:
        - `threads`: a list of threads generated by a 
                     ThreadPoolExecutor instance
        """
        for thread in concurrent.futures.as_completed(threads):
            if not thread.exception() == None:
                self.handle_exception(thread.exception())

    def handle_exception(self, exception):
        """Tread an exception as configured.
        
        Arguments:
        - `exception`: an exception to handle

        """
        if self.parameters.exception_handling == "report":
            sys.stderr.write(str(exception) + ".\n")
        elif self.parameters.exception_handling == "crash":
            raise(exception) 
    
    def count_mapped_nucleotides(self, read_file):
        """Count number of successfully mapped reads.

        Arguments:
        - `read_file`: orignal read file used to generate the mappings.
        """
        sam_parser = SamParser()
        nucleotide_counting = 0
        prev_entry = ""
        for entry in sam_parser.entries(
            self.paths.combined_mapping_file_a_filtered(read_file)):
            if entry['query'] == prev_entry:
                continue
            nucleotide_counting += len(entry['sequence'])
            prev_entry = entry['query']
        return(nucleotide_counting)

    # def lowest_number_of_mapped_nucleotides(self, genome_file):
    #     """Return the lowest number of mapping mapped nucleotides.

    #     Arguments:
    #     - `genome_file`: target genome file
    #     """
    #     lowest_number_of_mapped_nucleotides = min(
    #         [self._count_mapped_nucleotides(read_file, genome_file) 
    #      for var in collection:
    #              read_file in self.paths.read_files])
    #     # Avoid multiplication by zero
    #     if lowest_number_of_mapped_nucleotides == 0:
    #         lowest_number_of_nucleotides = 1
    #     return(lowest_number_of_mapped_nucleotides)

